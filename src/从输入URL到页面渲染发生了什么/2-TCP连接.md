

在拿到域名对应的IP地址之后，浏览器会以一个随机端口向服务的Web程序的80端口发起TCP连接请求

这个连接请求（原始的http请求经过TCP/IP4模型的层层封包）到达服务器端后，进入网卡，然后进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过netfiler防火墙的过滤，最终到达web程序，最终建立了TCP/IP的连接

tcp连接的建立和关闭均需要一个完善的确认机制，一般将连接称为三次握手，而连接关闭称为四次挥手

不论是三次握手还是四次挥手都需要数据从客户端到服务器的一次完整传输

将数据从客户端到服务端经历的一个完整时延包括：

- 发送时延：把消息中的所有比特转移到链路中需要的时间
- 传播时延：消息从发送端到接受端需要的时间
- 处理时延：处理分组首部，检查位错误及确定分组目标所需的时间
- 排队时延：到来的分组排队等待处理的时间

以上时延的总和就是客户端到服务端的总延迟时间，因此每次连接的建立和断开都是有巨大的代价的

**三次握手**

- 第一次握手：客户端发送syn包的数据包到服务器，并进入SYN_SEND状态，等待服务器确认
- 第二次握手：服务器收到syn包，必须确认客户端的syn，同时自己发送一个syn包，即SYN+ACK包
- 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认的ACK

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去

三次握手是不携带数据的，而是在握手完毕才开始数据传输。如果每次数据请求都需要重新进行完整的tcp连接建立，通信时延的耗时是难以估量的

## HTTP1.0

在http1.0时代，每个TCP连接只能发送一个请求，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（TCP的拥塞控制开始时会启动慢启动算法）。在数据传输的开始只能发送少量包，并随着网络状态良好（无拥塞）指数增长，但是遇到拥塞哟要重新从1个包开始进行传输

**为了避免tcp连接的三次握手耗时以及慢启动引起的发起速度慢的情况，应尽量减少tcp连接的次数**

由于http1.0每个数据请求都需要重新建立连接的特点使得http1.0版本的性能比较差，随着网页加载的外部资源越来越多，这个问题就愈发突出了。为了解决这个问题，有些浏览器在请求时用了一个非标准的Connection字段，用以建立一个可以复用的tcp连接，直到客户端或者服务器主动结束连接

## HTTP1.1

http1.1版本的最大变化就是引入了持久连接，即tcp连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`。当客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。对于同一个域名，大多数浏览器允许同时建立6个持久连接，相比于http1.0页面性能有了巨大提升



但是http1.1还是会有一个问题，那就是所有数据通信是按次序进行的，服务器只有处理完一个回应，才继续下一个。要是某一个的回应特别慢，就会让后面的请求排队等着，这被称为“队头阻塞”。

为了避免这个问题，有三种方式：

1. 减少请求数
2. 同时多开持久连接
3. 开启pipelinging

## HTTP2

http2有以下几个主要特点：

- **二进制协议**：http1.1版本的头信息是文本（ASCII编码），数据体可以是文本，也可以是二进制。http2则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为“帧”
- **多工**：复用tcp连接，一个连接里，客户端和浏览器都可以同时发送多个请求或回应
- **数据流**：因为http2的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应，因此必须对数据包做标记，指出它属于哪个回应。http2将每个请求或回应的数据包称为数据流。每一个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。
- **头信息压缩**：http2引入了头信息压缩机制，一方面头信息使用gzip或compress压缩后再发送，另一方面客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号
- **服务器推送**：http2允许服务器未经请求，主动向客户端发送资源

