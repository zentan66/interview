

## 垃圾回收算法

在频繁回收对象后，内存中就会存在大量不连续空间，专业名词叫「内存碎片」

当内存中出现了大量的内存碎片，如果需要分配较大的连续内存时，就有可能出现内存不足的情况



#### 什么时候垃圾回收

浏览器进行垃圾回收的时候，会暂停JavaScript脚本，等垃圾回收完毕再继续执行

对于普通应用这样没什么问题，但对于JS游戏、动画等连贯性要求比较高的应用



#### 垃圾回收中的数据类型

- 临时对象
  - 大部分对象在内存中存活的时间很短
  - 比如函数内部声明的变量或者块级作用域汇中的变量
- 长久对象
  - 生命周期很长的对象，比如全局的`window、DOM、Web API`等等

V8把堆分为新生代和老生代两个区域，新生代中存放临时对象，老生代中存放持久对象

让副垃圾回收期、主垃圾回收期分别负责新生代、老生代的垃圾回收

### 主垃圾回收器

负责老生代的垃圾回收，有两个特点：

- 对象占用空间大
- 对象存活时间长

使用「标记-清除」算法执行垃圾回收

1. 标记过程

   从一组根元素开始递归遍历这组根元素，在过程中能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据

2. 垃圾清除

3. 对多次标记-清除后产生的大量不连续的内存碎片需要进行内存整理

### 副垃圾回收器

负责新生代垃圾回收，通常只支持1-8M的容量

新生代被分为两个区域：一半是对象区域，一半是空闲区域

新加入的对象都被放入对象区域，等对象区域快满的时候，会执行一次垃圾清理

1. 先给对象区域所有垃圾做标记
2. 标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍
3. 复制完成后，对象区域会和空闲区域进行对调。将空闲区域中存活的对象放入对象区域里

因为副垃圾回收期操作比较频繁，所以为了执行效率，一般新生代的空间会被设置得比较小

一旦检测到空间装满了，就执行垃圾回收

### 分代收集

将堆分为新生代与老生代，多回收新生代，少回收老生代

### 增量收集

如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间的暂停

所以引擎将垃圾收集工作分为更小的块，每次处理一部分，多次处理

### 闲时收集

垃圾收集器只会在CPU空闲时尝试运行，以减少可能对代码执行的影响

