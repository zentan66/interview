### 浏览器

1. url输入到页面显示全过程

   - 输入url，敲击回车

   - dns解析

     ```
     1. 查找浏览器自身DNS缓存
     2. 系统DNS缓存
     3. 向本地配置的首选DNS服务器（运营商）发起域名解析请求（UDP协议53端口）
     4. 在根域DNS中查找
     ```

   - 建立tcp连接

   

2. DOM树的构建是文档加载完开始的？

   ```
   DOM树的构建是从接受到文档开始的，先将字节转化为字符，然后字符转化为标记，接着标记构建dom树。这个过程被分为标记化和树构建
   而这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。
   ```

3. 渲染树是在DOM树和CSS样式树构建完毕才开始构建的么？

   ```
   这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一边解析，一边渲染的工作现象。
   ```

   

4. DNS如何解析的，怎么拿到地址的

5. DNS解析耗时吗？如何优化

6. v8引擎如何解析一段js代码

7. tcp连接过程（三次握手，四次挥手）

8. 浏览器渲染流程

9. 重绘和重排，如何优化

```
浏览器渲染机制：
浏览器采用流式布局模型

重绘：
由于节点的几何属性发生改变或者样式发生改变而不会影响布局

回流：
布局或者几何属性需要改变，其变化涉及到部分页面（或是整个页面）的布局更新

优化：
CSS
1.使用transform替代top
2.使用visibility替代display:none
3.避免使用table布局
4.尽可能在dom树最末端改变class
5.避免设置多层内联样式
6.将动画应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局
7.避免使用CSS表达式
8.将频繁重绘或回流的节点设置为图层，图层能阻止该节点的渲染行为影响其他的节点
9.CSS3硬件加速（GPU加速）

JavaScript
1. 避免频繁操作样式，最好一次性重写style属性
2. 避免频繁操作DOM，创建一个documentFragment
3. 避免频繁读取会引发回流/重绘的属性，如果确实需要，可以用一个变量缓存
4. 对具有复杂动画的元素使用绝对定位
```



哪些属性可以避免重绘和重排

```

```



缓存，强缓存是谁设置的？html可以缓存么？

```
//
```

浏览器缓存读取规则，请求什么时候from memory cache和from disk cache？哪些数据什么时候存放到Memory Cache和Disk Cache中？



### 网络

1. http请求方式
2. get和post区别
3. restful规范
4. 跨域如何解决
5. 网络请求中如何把大文件资源压缩传输（gzip）
6. 文件断点续传
7. http缓存头部字段
8. Cookie，token和session的区别

```
cookie是服务端发送到用户浏览器并且保存到本地的一小块数据，会在浏览器下次向同意服务器发送请求时被携带到服务器
```

9. cookie和token都存放在header中，为什么不会劫持token

```
1. 攻击者可以通过xss拿到用户的cookie
2. 或者通过csrf在同个浏览器下面通过浏览器会自动带上cookie的特性
token
1. 不会被浏览器带上
2. token是放在jwt里面下发给客户端的，不一定存储在那里，可以通过jwt+ip方式防止被劫持
```

10. HTTPS握手过程中，客户端如何验证证书的合法性

```
1. 检验证书的颁发机构是否受客户端信任
2. 通过CRL或OCSP的方式校验证书是否被吊销
3. 对比系统时间，校验证书是否在有效期内
4. 通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致
```

11. token如何加密

```
jwt举例：
1. 需要一个secret（随机数）
2. 后端利用secret和加密算法对payload（账号密码）生成一个字符串（token）返回给前端
3. 前端每次request在header中带上token
4. 后端用同样的算法解密
```

12. 介绍下HTTPS中间人攻击

```
https协议由http+ssl协议构成

中间人攻击过程：
1. 服务器向客户端发送公钥
2. 攻击者拦截公钥
3. 攻击者伪造一个公钥，发给客户端
4. 客户端收到伪造的公钥后，生成加密hash值发给服务器
5. 攻击者获得加密hash值，用自己的私钥解密获得真秘钥
6. 生成假的加密hash值，发送给服务器
7. 服务器用私钥解密获得假秘钥
8. 服务器用秘钥加密传输信息

防范方法：
服务器在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性
```

13. 理解什么是协议？，了解TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用

```
网络协议是通信计算机双方必须共同遵从的一组约定，为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则
TCP/IP网络协议族分为：应用层、运输层、网络层、链路层
```

14. 有哪些协议是可靠的？TCP有哪些手段保证可靠交付？

```
//
```

15. HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别

```
HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。
一个请求报文由请求行、请求头部、空行和请求数据四个部分组成
请求行：GET /list HTTP/1.1
请求头：content-type: 'image/*'
```

### tcp 和 udp 有什么区别？tcp 怎样确保数据正确性？tcp 头包含什么？tcp 属于那一层？

**区别**

1. TCP面向连接，UDP无连接的
2. TCP提供可靠的服务，通过TCP传输的数据无差错，不丢失，不重复；UDP尽最大努力交付，不保证可靠交付
3. TCP面向字节流；UDP是面向报文的，没有拥塞控制
4. 每一条TCP连接都只能是点到点；UDP支持1对n
5. TCP首部开销20字节；UDP首部开销8字节
6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

**确保数据正确性**

1. 校验和：发送的数据包的二进制相加然后取反，监测数据在传输过程中的任何变化，如果收到段的校验和有差错，TCP将丢弃这个报文段和不确认收到此报文段
2. 确认应答+序列号：TCP给发送的每一个包进行变好，接收方对数据包进行排序，把有序数据传送给应用层
3. 超时重传：当TCP发出一个段后，会启动一个定时器，等待目的端接收到这报文段，如果不能及时收到一个确认，将重发这个报文段
4. 流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接受端只允许发送端发送接受端缓冲区能接纳的数据，当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失
5. 拥塞控制：当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据前对比接收方发过来的计时窗口，取小

**TCP头包含什么**

1. 16位端口号：告知主机该报文段来自哪里，传给哪个上层协议/应用
2. 32位序列号：一次TCP通信过程中某一个传输方向上的字节流的每个字节的编号
3. 32位确认码：用作对另一方发送来的TCP报文段的响应
4. 4位头部长度：表示该TCP头部有多少32bit
5. 6位标志位
6. 16位窗口大小：流量控制
7. 16位校验和：TCP可靠传输的一个重要保障
8. 16位紧急指针
9. TCP头部选项：可变长的可选信息

### 介绍下 Https，和 http 的区别是什么？https 为什么比 http 安全？如何进行配置？